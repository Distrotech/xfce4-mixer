%{
#ifdef HAVE_CONFIG_H
#  include <config.h>
#endif
%}
%a{
#include <gtk/gtk.h>
#include <libxfcegui4/libxfcegui4.h>
#include <libxfce4util/libxfce4util.h>
#include "xfce-mixer-preferences.h"
#include "vc.h"
#include "xfce-mixer-cache-vc.h"
#include "launcher-entry.h"

/* why is this deprecated when it is needed by combo ? O_o */
GtkWidget *gtk_list_item_new_with_label (const gchar *label);

%}
%h{
#include "helpers_h.inc"
%}

%{
#include "string_option_menu.h"

#define FHELPERS1
#include "helpers.inc"

#include "stringlist.inc"

%}

class Xfce:Mixer:Prefbox from Gtk:VBox {
	protected GtkCombo *device_cb;
	protected GtkOptionMenu *master_om;
	protected GList *master_lst = NULL
		destroy {
			stringlist_free(VAR);
			VAR = NULL;
		};

	protected GtkCombo *execu_cb;
	/*protected GtkEntry *execu_entry;*/
	/*protected GtkCheckButton *startup_nf_c;*/
	/*protected GtkCheckButton *in_terminal_c;*/
	private delayer_t device_entry_delayer = 0
		destroy { delayer_free (VAR); };
	protected LauncherEntry *launcher_entry = NULL;
	protected GtkWidget *click_b = NULL;

	public void fill_defaults(self)
	{
		launcher_entry_set_command (self->launcher_entry, "xfce4-mixer", FALSE, TRUE);
		gtk_entry_set_text (GTK_ENTRY (self->device_cb->entry), "");
		emit self_device_changed (self);
	}

	protected void fill_device_list(self)
	{
		GList *gl;

		gl = vc_get_device_list ();
		if (gl) {
			gtk_combo_set_popdown_strings (GTK_COMBO (self->device_cb), gl);
			vc_free_device_list (gl);
		} else {
			/* TODO: clear popdown list O_o */
			/* gtk_combo_set_popdown_strings (, NUL); issues warning */
		}
	}

	protected void fill_master_list(self)
	{
		stringlist_free (self->master_lst);
		self->master_lst = NULL;
		xfce_mixer_cache_vc_foreach (master_enum_cb, &self->master_lst);

		fill_string_option_menu (self->master_om, self->master_lst);
	}

	protected gchar *find_name_by_master_i (self, gint master_i)
	{
		gint i;
		GList *g;
		gchar *s;

		if (master_i == -1)
			return NULL;

		i = 0;
		g = self->master_lst;
		while (g) {
			s = (gchar *)g->data;
			if (s) {
				if (i == master_i)
					return g_strdup (s);
			}

			g = g_list_next (g);
			++i;
		}
		return NULL;
	}

	protected gint find_master_by_name (self, gchar const *name)
	{
		gint i;
		gint master_i;
		GList *g;
		gchar *s;

		master_i = -1;
		if (!name) {
			return master_i;
		}

		i = 0;
		g = self->master_lst;

		while (g) {
			s = (gchar *)g->data;
			if (s) {
				if (g_str_equal (s, name))
					master_i = i;
			}

			g = g_list_next (g);
			++i;
		}

		return master_i;
	}


	signal first NONE (NONE)
	void device_changed (self)
	{
		gint omi;
		gchar const *txt;
		gchar *master;
		txt = gtk_entry_get_text (GTK_ENTRY (self->device_cb->entry));
		if (txt && txt[0]) {
			vc_set_device (txt);
		} else {
			vc_set_device (vc_get_device ());
		}

		omi = gtk_option_menu_get_history (self->master_om);
		master = self_find_name_by_master_i (self, omi);

		self_fill_master_list (self);
		omi = -1;
		if (master) {
			omi = self_find_master_by_name (self, master);
			g_free (master);
		}

		/*if (omi == -1)
			omi = self_find_master (self);
		*/

		gtk_option_menu_set_history (self->master_om, omi);

	}

	init(self)
	{
		GtkWidget *dentry;
		GtkWidget *item;

		gtk_box_set_spacing (GTK_BOX (self), 5);
		self->device_cb = GTK_COMBO (gtk_combo_new ());
		self->master_om = GTK_OPTION_MENU (gtk_option_menu_new ());


		gtk_container_set_border_width (GTK_CONTAINER (self), 5);
		gtk_box_pack_start (GTK_BOX (self), twocol_label ("Device:", GTK_WIDGET (self->device_cb)), FALSE, FALSE, 0);
		gtk_box_pack_start (GTK_BOX (self), twocol_label ("Wannabe Master:", GTK_WIDGET (self->master_om)), FALSE, FALSE, 0);

		gtk_box_pack_start (GTK_BOX (self), headline ("When clicked", &self->click_b), FALSE, FALSE, 0);


		gtk_entry_set_max_length (GTK_ENTRY (self->device_cb->entry), 50);

		gtk_combo_set_value_in_list (GTK_COMBO (self->device_cb), FALSE, TRUE);
		if (self->execu_cb)
			gtk_combo_set_value_in_list (GTK_COMBO (self->execu_cb), FALSE, TRUE);

		self_fill_device_list (self);

		emit self_device_changed (self);

		dentry = GTK_WIDGET (self->device_cb->entry);
		g_signal_connect_swapped (G_OBJECT (dentry), "changed", G_CALLBACK (self_device_changed_cb), self);

		if (self->execu_cb && g_find_program_in_path ("xfce4-mixer")) {
			item = gtk_list_item_new_with_label ("xfce4-mixer");
			gtk_widget_show (item);
			gtk_combo_set_item_string (GTK_COMBO (self->execu_cb), GTK_ITEM (item), "xfce4-mixer");
			gtk_container_add (GTK_CONTAINER (GTK_COMBO (self->execu_cb)->list), item);
		}
	}

	protected void add_command_box (self)
	{
		self->launcher_entry = launcher_entry_new ();
		self->execu_cb = NULL; /*self->ic->combo;*/
		/*self->execu_entry = self->ic->command_entry;*/
		/*self->startup_nf_c = GTK_CHECK_BUTTON (self->ic->sn_checkbutton);*/
		/*self->in_terminal_c = GTK_CHECK_BUTTON (self->ic->term_checkbutton);*/
		gtk_widget_show (GTK_WIDGET (launcher_entry_get_widget (self->launcher_entry)));
		gtk_box_pack_start (GTK_BOX (self->click_b), GTK_WIDGET (launcher_entry_get_widget (self->launcher_entry)), FALSE, FALSE, 0);
	}

	protected gboolean device_changed_delayed_cb (self)
	{
		/*printf ("delayed\n");*/
		emit self_device_changed (self);
		return FALSE;
	}

	protected void device_changed_cb (self, GtkEditable *e)
	{
		delayer_restart (
			&self->_priv->device_entry_delayer, 
			500, (GSourceFunc) (self_device_changed_delayed_cb), 
			self
		);
	}

	public XfceMixerPrefbox *new(void)
	{
		XfceMixerPrefbox* w;
		w = (XfceMixerPrefbox*) (GET_NEW);
		xfce_mixer_prefbox_add_command_box (XFCE_MIXER_PREFBOX (w));
		return w;
	}

	public void fill_preferences(self, XfceMixerPreferences *p)
	{
		gint omi;
		gchar* launcher_command;
		gboolean launcher_run_in_terminal;
		gboolean launcher_use_startup_notification;
		gchar* device;
		gchar* master_control;

		launcher_command = NULL;
		launcher_run_in_terminal = FALSE;
		launcher_use_startup_notification = FALSE;
		device = NULL;
		master_control = NULL;

		if (!p) {
			self_fill_defaults (self);
			return;
		}

		g_object_get (G_OBJECT (p),
			"launcher_command", &launcher_command, 
			"launcher_run_in_terminal", &launcher_run_in_terminal,
			"launcher_use_startup_notification", &launcher_use_startup_notification,
			"device", &device,
			"master", &master_control,
			NULL
		);

		launcher_entry_set_command (self->launcher_entry, 
			nvl (launcher_command, "xfce4-mixer"),
			launcher_run_in_terminal,
			launcher_use_startup_notification
		);

		gtk_entry_set_text (GTK_ENTRY (self->device_cb->entry), nvl (device, ""));

		omi = self_find_master_by_name (self, master_control);

		gtk_option_menu_set_history (self->master_om, omi);

		if (master_control) {
			g_free (master_control);
			master_control = NULL;
		}

		if (device) {
			g_free (device);
			device = NULL;
		}

		if (launcher_command) {
			g_free (launcher_command);
			launcher_command = NULL;
		}

		emit self_device_changed (self);
	}

	public void save_preferences (self, XfceMixerPreferences *p)
	{
		gint omi;
		gchar *execu;
		gchar const *device;
		gchar *master;
		gboolean startup_nf;
		gboolean in_terminal;

		if (!p)
			return;

		device = gtk_entry_get_text (GTK_ENTRY (self->device_cb->entry));
		emit self_device_changed (self);

		omi = gtk_option_menu_get_history (self->master_om);
		master = self_find_name_by_master_i (self, omi);

		launcher_entry_get_command (self->launcher_entry, &execu, &in_terminal, &startup_nf);

		g_object_set (G_OBJECT (p),
			"device", device,
			"launcher_command", execu,
			"master", master,
			"launcher_use_startup_notification", startup_nf,
			"launcher_run_in_terminal", in_terminal,
			NULL
		);

		if (execu)
			g_free (execu);

		if (master)
			g_free (master);
	}
}

