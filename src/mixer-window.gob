%{
#ifdef HAVE_CONFIG_H
#  include <config.h>
#endif
%}

%a{
#include <gtk/gtk.h>
#include "xfce-mixer-view.h"
#include "xfce-mixer-profile.h"
#include "main.h"
#include "xfce-mixer-mcs-client.h"
%}
%{
#include <gtk/gtk.h>
#include <gdk/gdkx.h>
#include <libxfce4util/i18n.h>
#include <libxfce4util/util.h>
#include "menus.h"
#include "main.h"
#include "stringlist.inc"
#define CHANNEL "sound"
#define MIXER_ROOT "Mixer"

%}


class Xfce:Mixer:Window from Gtk:Window {
	public Xfce:Mixer:View *view = NULL;
	public Gtk:Box *box = NULL;
	protected Gtk:Menu:Bar *menubar = NULL;
	public Xfce:Mixer:Profile *profile = NULL
		unrefwith g_object_unref;
	protected Gtk:Accel:Group *accelgroup = NULL;
	public Xfce:Mixer:Mcs:Client *mcsc = NULL
		unrefwith g_object_unref;

	protected gchar *fname = NULL
		destroywith g_free; /* name of the xml config file containing the window position */

	private gboolean sticky = FALSE;

	protected void set_profile(self, XfceMixerProfile *p)
	{
		if (p)
			g_object_ref (p);

		if (self->profile)
			g_object_unref (self->profile);

		self->profile = p;
		xfce_mixer_view_set_profile (self->view, p);
	}

	init(self)
	{
		XfceMixerProfile *p;
		self->box = GTK_BOX (gtk_vbox_new (FALSE, 0));
		gtk_widget_show (GTK_WIDGET (self->box));

		self->accelgroup = GTK_ACCEL_GROUP (gtk_accel_group_new ());
		self->menubar = xfce_mixer_create_main_menu (
			GTK_WINDOW (self), self->accelgroup
		);

		gtk_window_add_accel_group (GTK_WINDOW (self), self->accelgroup);

		g_object_unref (G_OBJECT (self->accelgroup));

		/*self->menubar = GTK_MENU_BAR (gtk_menu_bar_new ());*/
		gtk_widget_show (GTK_WIDGET (self->menubar));

		gtk_box_pack_start (self->box, GTK_WIDGET (self->menubar), FALSE, FALSE, 0);



		self->view = xfce_mixer_view_new ();

		gtk_widget_set_size_request (GTK_WIDGET (self->view), 600, -1);

		p = XFCE_MIXER_PROFILE (xfce_mixer_profile_new ("noname"));
		self_set_profile (self, p);
		g_object_unref (G_OBJECT (p));

		/*g_object_unref (G_OBJECT (self->profile));*/

		g_signal_connect_swapped (G_OBJECT (profiles),
			"profiles-changed", 
			G_CALLBACK (self_profiles_changed_cb),
			self);


		gtk_widget_show (GTK_WIDGET (self->view));

		gtk_box_pack_start (self->box, GTK_WIDGET (self->view), TRUE, TRUE, 0);

		gtk_container_add (GTK_CONTAINER (self), GTK_WIDGET (self->box));

		gtk_window_set_title (GTK_WINDOW (self), _("Volume Control"));

		self->mcsc = xfce_mixer_mcs_client_new ();
		g_object_set (self->mcsc, "channel", CHANNEL, NULL);
		g_signal_connect_swapped (G_OBJECT (self->mcsc), "changed", 
			G_CALLBACK(self_mcs_changed_cb), self);

		self_update_profiles_menu (self);

		g_signal_connect_swapped (G_OBJECT (self), "delete-event",
			G_CALLBACK(self_delete_event_cb), self);

		g_signal_connect_swapped (G_OBJECT (self), "window-state-event",
			G_CALLBACK(self_window_state_event_cb), self);

		self->fname = xfce_get_userfile ("xfce4-mixer", "config.xml", NULL);
		self_load_window_state (self);
	}

	protected gboolean window_state_event_cb (self, GdkEvent *event, GtkWidget *widget)
	{
		if (event->window_state.type == GDK_WINDOW_STATE) {
			selfp->sticky = event->window_state.new_window_state & GDK_WINDOW_STATE_STICKY;
		}
		return FALSE;
	}

	/* TODO handle screen-changed */

	protected void xml_goto_device(self, XfceMixerPxml *xml)
	{
		gchar *n;
		xfce_mixer_pxml_goto_root (xml);
		xfce_mixer_pxml_goto_children (xml);
		while (xml->node) {
			if (xfce_mixer_pxml_check_tag (xml, "device")) {
				n = xfce_mixer_pxml_get_prop (xml, "name");
				if (n && device && g_str_equal (n, device)) {
					g_free (n);
					return;
				}
				if (n)
					g_free (n);
			}

			xfce_mixer_pxml_goto_next (xml);
		}

		/* device does not exist yet in xml */
		xml->node = NULL;
		xfce_mixer_pxml_goto_root (xml);
		xml->node = xfce_mixer_pxml_create_text_child (xml, "device", NULL);
		xfce_mixer_pxml_set_prop (xml, "name", device);
	}

	protected void load_window_state(self)
	{
		XfceMixerPxml *xml;
		gint x, y;
		gint width, height;
		gint isticky;

		xml = xfce_mixer_pxml_new (MIXER_ROOT);
		g_object_set (G_OBJECT (xml), "fname", self->fname, NULL);

		self_xml_goto_device (self, xml);
		if (xfce_mixer_pxml_goto_child_tag (xml, "size")) {
			if (xfce_mixer_pxml_get_prop_int (xml, "width", &width)
			&& xfce_mixer_pxml_get_prop_int (xml, "height", &height)) {
				gtk_window_resize (GTK_WINDOW (self), width, height);
			}
		}

		self_xml_goto_device (self, xml);
		if (xfce_mixer_pxml_goto_child_tag (xml, "position")) {
			if (xfce_mixer_pxml_get_prop_int (xml, "x", &x) 
			&& xfce_mixer_pxml_get_prop_int (xml, "y", &y)) {
				gtk_window_move (GTK_WINDOW (self), x, y);
			}
		}

		/* if sticky: gtk_window_stick (GTK_WINDOW (self)); */
		/* sticking must be done before realizing */

		self_xml_goto_device (self, xml);
		if (xfce_mixer_pxml_goto_child_tag (xml, "state")) {
			if (xfce_mixer_pxml_get_prop_int (xml, "sticky", &isticky)) {
				if (isticky)
					gtk_window_stick (GTK_WINDOW (self));
				else
					gtk_window_unstick (GTK_WINDOW (self));
			}
		}

		g_object_unref (G_OBJECT (xml));
	}

	protected void save_window_state(self)
	{
		XfceMixerPxml *xml;
		gint x, y;
		gint width, height;

		xml = xfce_mixer_pxml_new (MIXER_ROOT);
		g_object_set (G_OBJECT (xml), "fname", self->fname, NULL);

		/*netk_window_get_geometry (win, &x, &y, &width, &height);*/

		/* this function doesnt work like I want it to: */
		/*gtk_widget_size_request (GTK_WIDGET (self), &req); */
		/*gtk_widget_size_request (GTK_WIDGET (self), &req); */
		gtk_window_get_position (GTK_WINDOW (self), &x, &y);
		gtk_window_get_size (GTK_WINDOW (self), &width, &height);

		/*g_warning ("save pos %d %d, size %d %d", x, y, width, height);*/

		self_xml_goto_device (self, xml);

		if (!xfce_mixer_pxml_goto_child_tag (xml, "position")) 
			xfce_mixer_pxml_goto_node (xml, 
				xfce_mixer_pxml_create_text_child (xml, "position", NULL)
			);

		xfce_mixer_pxml_set_prop_int (xml, "x", x);
		xfce_mixer_pxml_set_prop_int (xml, "y", y);

		self_xml_goto_device (self, xml);
		if (!xfce_mixer_pxml_goto_child_tag (xml, "size"))
			xfce_mixer_pxml_goto_node (xml, 
				xfce_mixer_pxml_create_text_child (xml, "size", NULL)
			);
		xfce_mixer_pxml_set_prop_int (xml, "width", width);
		xfce_mixer_pxml_set_prop_int (xml, "height", height);


		self_xml_goto_device (self, xml);
		if (!xfce_mixer_pxml_goto_child_tag (xml, "state"))
			xfce_mixer_pxml_goto_node (xml, 
				xfce_mixer_pxml_create_text_child (xml, "state", NULL)
			);
		xfce_mixer_pxml_set_prop_int (xml, "sticky", selfp->sticky ? 1 : 0);

		/* netk_window_is_sticky (win)); */
		/*, selfp->sticky ? 1 : 0); */

		g_object_unref (G_OBJECT (xml));
		/*g_object_unref (G_OBJECT (win));*/
	}

	protected gboolean delete_event_cb(self, GdkEvent *event, GtkWidget *widget)
	{
		self_save_window_state(self);
		return FALSE;
	}

	protected void mcs_changed_cb(self, GtkWidget *widget)
	{
		/*g_warning ("mcs changed");*/
		self_reset_profile (self);
	}

	protected void profiles_changed_cb (self, GObject *profiles)
	{
		/* TODO avoid loop? */
		if (!self->view || !self->menubar)
			return;

		self_update_profiles_menu (self);
	}

	protected void view_profile_activate_cb (self, GtkWidget *w)
	{
		GList *g, *gp;
		gchar const *n;
		XfceMixerProfile *p;

		if (!gtk_check_menu_item_get_active (
			GTK_CHECK_MENU_ITEM (w)
		))
			return;

		g = gtk_container_get_children (GTK_CONTAINER (w));
		gp = g;
		n = NULL;
		if (gp)
			n = gtk_label_get_text (GTK_LABEL (gp->data));

		if (!n) {
			g_list_free (g);
			return;
		}

		p = xfce_mixer_profiles_get_profile (profiles, n);
		if (p) {
			/*g_warning ("profile_activate_cb init %X", (int)p);
			g_warning ("profile name %s", xfce_mixer_profile_get_title (p));*/
			self_set_profile (self, p);
			/*self_reset_profile (self);TODO remove this*/
			g_object_unref (G_OBJECT (p));
			/*g_warning ("profile_activate_cb done");*/
		}

		if (g)
			g_list_free (g);
	}

	protected void update_profiles_menu (self)
	{
		XfceMixerProfile const *currentp;
		GtkContainer *container;
		GList *g, *gp;
		GtkWidget *mi;
		gchar const *currentpn;
		gchar const *n;
		GSList *group;
		currentpn = NULL;
		currentp = xfce_mixer_view_get_profile (self->view);
		if (currentp)
			currentpn = xfce_mixer_profile_get_title ((XfceMixerProfile *)currentp);

		/* self->menubar, View menu: */
		/* for each v.child(): */
		/*   if child == seperator: break */
		/*   child.destroy() */

		container = GTK_CONTAINER (self->menubar);
		if (!container)
			return;

		g = gtk_container_get_children (container);
		if (!g)
			return;

		mi = GTK_WIDGET (g_list_nth_data (g, 1));
		if (!mi) {
			g_list_free (g);
			return;
		}

		container = GTK_CONTAINER (gtk_menu_item_get_submenu (GTK_MENU_ITEM (mi)));

		g_list_free (g);

		if (!container)
			return;

		g = gtk_container_get_children (container);
		if (!g)
			return;
		gp = g;
		while (gp) {
			if (!GTK_IS_RADIO_MENU_ITEM (gp->data))
				break;

			gtk_widget_destroy (GTK_WIDGET (gp->data));
			gp = g_list_next (gp);
		}

		if (g)
			g_list_free (g);


		/* profiles.load() */
		/* for n in profiles.get_profile_names() */
		/*   v.insert(0, gtk.MenuItem(n).show()) */

		g = xfce_mixer_profiles_get_profile_names (profiles);

		/*g = g_list_append (g, g_strdup ("dummy"));*/
		/*g = g_list_append (g, g_strdup ("dummy2"));*/

		gp = g;
		group = NULL;
		while (gp) {
			n = (gchar const *)gp->data;
			mi = gtk_radio_menu_item_new_with_label (group, n);

			group = gtk_radio_menu_item_get_group (GTK_RADIO_MENU_ITEM (mi));

			g_signal_connect_swapped (G_OBJECT (mi),
				"activate", G_CALLBACK (self_view_profile_activate_cb),
				self);

			if (currentpn && g_str_equal (currentpn, n)) {
				gtk_check_menu_item_set_active (GTK_CHECK_MENU_ITEM (mi), TRUE);
			}

			/* make mi checkmenuitems */
			gtk_widget_show (GTK_WIDGET (mi));
			gtk_menu_shell_prepend (GTK_MENU_SHELL (container), mi);

			gp = g_list_next (gp);
		}
		if (g)
			stringlist_free (g);

	}

	public GtkWidget *new(void)
	{
		return GTK_WIDGET (GET_NEW);
	}

	public void refresh (self)
	{
		if (self->profile)
			xfce_mixer_profile_refresh_views (self->profile);
	}

	public void reset_profile (self)
	{
		if (self->view)
			xfce_mixer_view_set_profile (self->view, self->profile);

		/*
		if (self->profile)
			xfce_mixer_profile_refresh_views (self->profile);

		automatic.
		*/
	}

	public void refresh_value (self, gchar const *vcname)
	{
		if (self->view)
			xfce_mixer_view_refresh_value (self->view, vcname);
	}
}

