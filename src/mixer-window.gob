%{
#ifdef HAVE_CONFIG_H
#  include <config.h>
#endif
%}

%a{
#include <gtk/gtk.h>
#include "xfce-mixer-view.h"
#include "xfce-mixer-profile.h"
#include "main.h"
#include "xfce-mixer-mcs-client.h"
#include "xfce_sizehook.h"
%}
%{
#include <gtk/gtk.h>
#include <gdk/gdkx.h>
#include <libxfce4util/libxfce4util.h>
#include <libxfcegui4/libxfcegui4.h>
#include "menus.h"
#include "main.h"
#include "stringlist.inc"
#include <my-config.h>
#define CHANNEL "sound"
#define MIXER_ROOT "Mixer"

#define WINDOWSTATE_CONFIG_FILENAME "config.xml"
#define ACCELMAP_CONFIG_FILENAME "window.accelmap"

%}


class Xfce:Mixer:Window from Gtk:Window {
	public Xfce:Mixer:View *view = NULL;
	public Gtk:Box *box = NULL;
	protected Gtk:Menu:Bar *menubar = NULL;
	public Xfce:Mixer:Profile *profile = NULL
		unrefwith g_object_unref;
	protected Gtk:Accel:Group *accelgroup = NULL
		destroy {
			self_save_accelgroup (self);
		};
	public Xfce:Mixer:Mcs:Client *mcsc = NULL
		unrefwith g_object_unref;

	protected gchar *fname = NULL
		destroywith g_free; /* name of the xml config file containing the window position */

	protected gchar *accelmap_fname = NULL
		destroywith g_free; /* name of the config file containing the menu accelerators */

	protected void load_accelgroup(self)
	{
		gchar *tpath;
		tpath = my_config_get_path (self->accelmap_fname, CONFIG_LOAD);
		if (tpath) {
			gtk_accel_map_load (tpath);
			g_free (tpath);
		}
	}

	protected void save_accelgroup(self)
	{
		gchar *tpath;
		gchar *tmppath;
		gboolean withtemp;
		withtemp = FALSE;
		tpath = my_config_get_path (self->accelmap_fname, CONFIG_SAVE);
		if (tpath) {
			tmppath = my_config_get_temp_file_name (tpath);
			withtemp = (tmppath != NULL);

			if (withtemp) {
				gtk_accel_map_save (tmppath);
				g_free (tmppath);
				tmppath = NULL;

				my_config_commit_file (tpath);
			} else 
				gtk_accel_map_save (tpath);

			g_free (tpath);
		}
		/*gtk_accel_group_find (self->accelgroup, accelgroup_find_each_cb, self);*/
	}

	protected void set_profile(self, XfceMixerProfile *p)
	{
		if (p)
			g_object_ref (p);

		if (self->profile)
			g_object_unref (self->profile);

		self->profile = p;
		xfce_mixer_view_set_profile (self->view, p);
	}

	protected void set_my_icon(self)
	{
		GdkPixbuf *pb;
		XfceIconTheme *it;
		GdkScreen *screen;
		screen = gtk_window_get_screen (GTK_WINDOW (self));
		if (!screen)
			return;

		it = xfce_icon_theme_get_for_screen (screen);
		if (it) {
			pb = xfce_icon_theme_load_category (it, XFCE_ICON_CATEGORY_SOUND, 48);
			if (pb) {
				gtk_window_set_icon (GTK_WINDOW (self), pb);
				g_object_unref (G_OBJECT (pb));
			}

			/*g_object_unref (G_OBJECT (it));*/
		}
		/*g_object_unref (G_OBJECT (screen));*/
	}

	init(self)
	{
		XfceMixerProfile *p;

		self_set_my_icon (self);

		self->box = GTK_BOX (gtk_vbox_new (FALSE, 0));
		gtk_widget_show (GTK_WIDGET (self->box));

		self->accelgroup = GTK_ACCEL_GROUP (gtk_accel_group_new ());
		self->menubar = xfce_mixer_create_main_menu (
			GTK_WINDOW (self), self->accelgroup
		);

		gtk_window_add_accel_group (GTK_WINDOW (self), self->accelgroup);

		g_object_unref (G_OBJECT (self->accelgroup));

		/*self->menubar = GTK_MENU_BAR (gtk_menu_bar_new ());*/
		gtk_widget_show (GTK_WIDGET (self->menubar));

		gtk_box_pack_start (self->box, GTK_WIDGET (self->menubar), FALSE, FALSE, 0);



		self->view = xfce_mixer_view_new ();

		/*gtk_widget_set_size_request (GTK_WIDGET (self->view), 600, -1);*/
		gtk_window_set_default_size (GTK_WINDOW (self), 600, -1);

		p = XFCE_MIXER_PROFILE (xfce_mixer_profile_new ("noname"));
		self_set_profile (self, p);
		g_object_unref (G_OBJECT (p));

		/*g_object_unref (G_OBJECT (self->profile));*/

		g_signal_connect_swapped (G_OBJECT (profiles),
			"profiles-changed", 
			G_CALLBACK (self_profiles_changed_cb),
			self);


		gtk_widget_show (GTK_WIDGET (self->view));

		gtk_box_pack_start (self->box, GTK_WIDGET (self->view), TRUE, TRUE, 0);

		gtk_container_add (GTK_CONTAINER (self), GTK_WIDGET (self->box));

		gtk_window_set_title (GTK_WINDOW (self), _("Volume Control"));

		self->mcsc = xfce_mixer_mcs_client_new ();
		g_object_set (self->mcsc, "channel", CHANNEL, NULL);
		g_signal_connect_swapped (G_OBJECT (self->mcsc), "changed", 
			G_CALLBACK(self_mcs_changed_cb), self);

		self_update_profiles_menu (self);

		self->fname = g_strdup (WINDOWSTATE_CONFIG_FILENAME);
		self_load_window_state (self);

		self->accelmap_fname = g_strdup (ACCELMAP_CONFIG_FILENAME);
		self_load_accelgroup (self);

	}

	/* TODO handle screen-changed */

	protected void xml_goto_device(self, XfceMixerPxml *xml)
	{
		gchar *n;
		xfce_mixer_pxml_goto_root (xml);
		xfce_mixer_pxml_goto_children (xml);
		while (xml->node) {
			if (xfce_mixer_pxml_check_tag (xml, "device")) {
				n = xfce_mixer_pxml_get_prop (xml, "name");
				if (n && device && g_str_equal (n, device)) {
					g_free (n);
					return;
				}
				if (n)
					g_free (n);
			}

			xfce_mixer_pxml_goto_next (xml);
		}

		/* device does not exist yet in xml */
		xml->node = NULL;
		xfce_mixer_pxml_goto_root (xml);
		xml->node = xfce_mixer_pxml_create_text_child (xml, "device", NULL);
		xfce_mixer_pxml_set_prop (xml, "name", device);
	}

	protected void load_window_state(self)
	{
		XfceMixerPxml *xml;
		gchar *tpath;
		gint x, y;
		gint width, height;
		gint isticky;

		t_window_state *s;
		s = g_new0 (t_window_state, 1);
		s->valid = FALSE;
		s->width = -1;
		s->height = -1;
		s->sticky = FALSE;

		tpath = my_config_get_path (self->fname, CONFIG_LOAD);
		if (tpath) {
			xml = xfce_mixer_pxml_new (MIXER_ROOT);
			g_object_set (G_OBJECT (xml), "fname", tpath, NULL);
			g_free (tpath);
			tpath = NULL;

			self_xml_goto_device (self, xml);
			if (xfce_mixer_pxml_goto_child_tag (xml, "size")) {
				if (xfce_mixer_pxml_get_prop_int (xml, "width", &width)
				&& xfce_mixer_pxml_get_prop_int (xml, "height", &height)) {
					s->width = width;
					s->height = height;
				}
			}

			self_xml_goto_device (self, xml);
			if (xfce_mixer_pxml_goto_child_tag (xml, "position")) {
				if (xfce_mixer_pxml_get_prop_int (xml, "x", &x) 
				&& xfce_mixer_pxml_get_prop_int (xml, "y", &y)) {
					s->x = x;
					s->y = y;
					s->valid = TRUE;
				}
			}

			/* if sticky: gtk_window_stick (GTK_WINDOW (self)); */
			/* sticking must be done before realizing */

			self_xml_goto_device (self, xml);
			if (xfce_mixer_pxml_goto_child_tag (xml, "state")) {
				if (xfce_mixer_pxml_get_prop_int (xml, "sticky", &isticky)) {
					s->sticky = isticky;
				}
			}

			self_xml_goto_device (self, xml);
			if (self->view)
				xfce_mixer_view_load_state (self->view, xml);

			g_object_unref (G_OBJECT (xml));

		}
		xfce_hook_window_state_swapped
			(GTK_WINDOW (self), s, 
			(XfceSizehookCallback)self_save_window_state_cb, self);
	}

	protected void save_window_state_cb(self, t_window_state *s, GtkWindow *w)
	{
		self_save_window_state(self, s);
	}

	protected void save_window_state(self, t_window_state *s)
	{
		XfceMixerPxml *xml;
		gchar *tpath;
		gchar *tmppath;
		gboolean withtemp;

		if (!s || !s->valid)
			return;

		withtemp = FALSE;

		tpath = my_config_get_path (self->fname, CONFIG_SAVE);
		if (tpath) {
			tmppath = my_config_get_temp_file_name (tpath);
			withtemp = (tmppath != NULL);
			xml = xfce_mixer_pxml_new (MIXER_ROOT);

			if (withtemp) {
				g_object_set (G_OBJECT (xml), "fname", tmppath, NULL);
				g_free (tmppath);
				tmppath = NULL;
			} else
				g_object_set (G_OBJECT (xml), "fname", tpath, NULL);

			self_xml_goto_device (self, xml);

			if (!xfce_mixer_pxml_goto_child_tag (xml, "position")) 
				xfce_mixer_pxml_goto_node (xml, 
					xfce_mixer_pxml_create_text_child (xml, "position", NULL)
				);
	
			xfce_mixer_pxml_set_prop_int (xml, "x", s->x);
			xfce_mixer_pxml_set_prop_int (xml, "y", s->y);
	
			self_xml_goto_device (self, xml);
			if (!xfce_mixer_pxml_goto_child_tag (xml, "size"))
				xfce_mixer_pxml_goto_node (xml, 
					xfce_mixer_pxml_create_text_child (xml, "size", NULL)
				);
			xfce_mixer_pxml_set_prop_int (xml, "width", s->width);
			xfce_mixer_pxml_set_prop_int (xml, "height", s->height);


			self_xml_goto_device (self, xml);
			if (!xfce_mixer_pxml_goto_child_tag (xml, "state"))
				xfce_mixer_pxml_goto_node (xml, 
					xfce_mixer_pxml_create_text_child (xml, "state", NULL)
				);
			xfce_mixer_pxml_set_prop_int (xml, "sticky", s->sticky ? 1 : 0);

			self_xml_goto_device (self, xml);
			if (self->view)
				xfce_mixer_view_save_state (self->view, xml);

			/* netk_window_is_sticky (win)); */
			/*, selfp->sticky ? 1 : 0); */

			g_object_set (G_OBJECT (xml), "fname", NULL, NULL);
			g_object_unref (G_OBJECT (xml));
			/*g_object_unref (G_OBJECT (win));*/

			my_config_commit_file (tpath);
			g_free (tpath);
			tpath = NULL;
		}
		g_free (s);
	}

	protected void mcs_changed_cb(self, GtkWidget *widget)
	{
		self_reset_profile (self);
	}

	protected void profiles_changed_cb (self, GObject *profiles)
	{
		/* TODO avoid loop? */
		if (!self->view || !self->menubar)
			return;

		self_update_profiles_menu (self);
	}

	protected void view_profile_activate_cb (self, GtkWidget *w)
	{
		GList *g, *gp;
		gchar const *n;
		XfceMixerProfile *p;

		if (!gtk_check_menu_item_get_active (
			GTK_CHECK_MENU_ITEM (w)
		))
			return;

		g = gtk_container_get_children (GTK_CONTAINER (w));
		gp = g;
		n = NULL;
		if (gp)
			n = gtk_label_get_text (GTK_LABEL (gp->data));

		if (!n) {
			g_list_free (g);
			return;
		}

		p = xfce_mixer_profiles_get_profile (profiles, n);
		if (p) {
			self_set_profile (self, p);
			/*self_reset_profile (self);TODO remove this*/
			g_object_unref (G_OBJECT (p));
		}

		if (g)
			g_list_free (g);
	}

	protected void update_profiles_menu (self)
	{
		XfceMixerProfile const *currentp;
		GtkContainer *container;
		GList *g, *gp;
		GtkWidget *mi;
		gchar const *currentpn;
		gchar const *n;
		GSList *group;
		currentpn = NULL;
		currentp = xfce_mixer_view_get_profile (self->view);
		if (currentp)
			currentpn = xfce_mixer_profile_get_title ((XfceMixerProfile *)currentp);

		/* self->menubar, View menu: */
		/* for each v.child(): */
		/*   if child == seperator: break */
		/*   child.destroy() */

		container = GTK_CONTAINER (self->menubar);
		if (!container)
			return;

		g = gtk_container_get_children (container);
		if (!g)
			return;

		mi = GTK_WIDGET (g_list_nth_data (g, 1));
		if (!mi) {
			g_list_free (g);
			return;
		}

		container = GTK_CONTAINER (gtk_menu_item_get_submenu (GTK_MENU_ITEM (mi)));

		g_list_free (g);

		if (!container)
			return;

		g = gtk_container_get_children (container);
		if (!g)
			return;
		gp = g;
		while (gp) {
			if (!GTK_IS_RADIO_MENU_ITEM (gp->data))
				break;

			gtk_widget_destroy (GTK_WIDGET (gp->data));
			gp = g_list_next (gp);
		}

		if (g)
			g_list_free (g);


		/* profiles.load() */
		/* for n in profiles.get_profile_names() */
		/*   v.insert(0, gtk.MenuItem(n).show()) */

		g = xfce_mixer_profiles_get_profile_names (profiles);

		/*g = g_list_append (g, g_strdup ("dummy"));*/
		/*g = g_list_append (g, g_strdup ("dummy2"));*/

		gp = g;
		group = NULL;
		while (gp) {
			n = (gchar const *)gp->data;
			mi = gtk_radio_menu_item_new_with_label (group, n);

			group = gtk_radio_menu_item_get_group (GTK_RADIO_MENU_ITEM (mi));

			g_signal_connect_swapped (G_OBJECT (mi),
				"activate", G_CALLBACK (self_view_profile_activate_cb),
				self);

			if (currentpn && g_str_equal (currentpn, n)) {
				gtk_check_menu_item_set_active (GTK_CHECK_MENU_ITEM (mi), TRUE);
			}

			/* make mi checkmenuitems */
			gtk_widget_show (GTK_WIDGET (mi));
			gtk_menu_shell_prepend (GTK_MENU_SHELL (container), mi);

			gp = g_list_next (gp);
		}
		if (g)
			stringlist_free (g);

	}

	public GtkWidget *new(void)
	{
		return GTK_WIDGET (GET_NEW);
	}

	public void refresh (self)
	{
		if (self->profile)
			xfce_mixer_profile_refresh_views (self->profile);
	}

	public void reset_profile (self)
	{
		if (self->view)
			xfce_mixer_view_set_profile (self->view, self->profile);

		/*
		if (self->profile)
			xfce_mixer_profile_refresh_views (self->profile);

		automatic.
		*/
	}

	public void refresh_value (self, gchar const *vcname)
	{
		if (self->view)
			xfce_mixer_view_refresh_value (self->view, vcname);
	}
}

