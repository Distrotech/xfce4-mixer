%{
#ifdef HAVE_CONFIG_H
#include <config.h>
#endif
%}
%a{
#include <gtk/gtk.h>
#include "xfce-mixer-profilebox-detail.h"
#include "xfce-mixer-profiles.h"
#include "xfce-mixer-profile.h"
%}
%{
#include <libxfce4util/i18n.h>
#define NO_TREE_CHECK_COLUMN
#include "helpers3.inc"
#include "stringlist.inc"
#include "msgdlg.inc"
#include "main.h"

static void profile_insert_cb (GtkWidget *w, gpointer user_data);
static void profile_delete_cb (GtkWidget *w, gpointer user_data);

/*static GList *list_remove_nth (GList *go, gint i, void ())
{
	gpointer d;
	d = g_list_nth_data (go, i);
	return g_list_remove (go, d);
}*/

static void each_selstring_cb (GtkTreeModel *model, GtkTreePath *path, GtkTreeIter *iter, gpointer data)
{
	GList **gg;
	gchar *s;
	gg = (GList **)data;

	gtk_tree_model_get (model, iter, 0, &s, -1);
	if (s) {
		*gg = g_list_append (*gg, s);
	}
}

/*
static void profiles_free (GList *go)
{
	GList *g;
	GObject *p;
	g = go;
	while (g) {
		p = G_OBJECT (g->data);
		g_object_unref (p);

		g = g_list_next (g);
	}

	if (go)
		g_list_free (go);
}
*/

%}

class Xfce:Mixer:Profilebox from Gtk:VBox {
	protected GtkWidget *sep1;
	protected GtkWidget *sep2;
	protected GtkLabel *device_label;
	protected GtkScrolledWindow *profiles_sw;
	protected GtkTreeView *profiles_tv;
	protected GtkTreeStore *profiles_model;
	protected GtkBox *profiles_box;
	protected GtkWidget *profiles_insert_button;
	protected GtkWidget *profiles_delete_button;

	protected GtkToolbar *profiles_toolbar;
	protected Xfce:Mixer:Profilebox:Detail *detail = NULL;
	protected GtkBox * hbox;
	protected gint profiles_updated_lock = 0;

	init (self)
	{
		GtkBox *devbox;
		GtkWidget *d1label;
		GtkWidget *dal;
		gchar const *dd;
		GtkTreeSelection *sels;

		devbox = GTK_BOX (gtk_hbox_new (FALSE, 5));
		d1label = gtk_label_new (_("Device:"));
		gtk_widget_show (GTK_WIDGET (d1label));
		gtk_box_pack_start (devbox, d1label, FALSE, FALSE, 0);

		dd = device;
		if (!dd)
			dd = "";

		self->device_label = GTK_LABEL (gtk_label_new (dd));
		gtk_widget_show (GTK_WIDGET (self->device_label));

		gtk_box_pack_start (devbox, GTK_WIDGET (self->device_label), FALSE, FALSE, 0);
		gtk_widget_show (GTK_WIDGET (devbox));

		self->hbox = GTK_BOX (gtk_hbox_new (FALSE, 0));
		gtk_widget_show (GTK_WIDGET (self->hbox));

		dal = gtk_alignment_new (0.5, 0.5, 0.0, 0.0);
		gtk_widget_show (GTK_WIDGET (dal));

		gtk_container_add (GTK_CONTAINER (dal), GTK_WIDGET (devbox));

		self->sep2 = gtk_hseparator_new ();
		gtk_widget_show (self->sep2);

		gtk_box_pack_start (GTK_BOX (self), GTK_WIDGET (dal), FALSE, FALSE, 0);
		gtk_box_pack_start (GTK_BOX (self), GTK_WIDGET (self->sep2), FALSE, FALSE, 3);
		gtk_box_pack_start (GTK_BOX (self), GTK_WIDGET (self->hbox), TRUE, TRUE, 3);

		self->detail = xfce_mixer_profilebox_detail_new ();
		gtk_widget_show (GTK_WIDGET (self->detail));

		self->sep1 = gtk_vseparator_new ();
		gtk_widget_show (self->sep1);

		self->profiles_box = GTK_BOX (gtk_vbox_new (FALSE, 0));
		gtk_widget_show (GTK_WIDGET (self->profiles_box));

		self->profiles_toolbar = GTK_TOOLBAR (gtk_toolbar_new ());

#if 0
		gtk_toolbar_append_item (self->profiles_toolbar,
			"test", "testtip", NULL, NULL/*icon*/, NULL/*callback*/,
			NULL/*user_data*/
		);
#endif

		gtk_toolbar_set_style (self->profiles_toolbar,
			GTK_TOOLBAR_ICONS
		);

		self->profiles_insert_button =
			gtk_toolbar_insert_stock (self->profiles_toolbar,
			GTK_STOCK_ADD,
			_("Create new profile"),
			NULL,
			(GtkSignalFunc)profile_insert_cb /*cb*/,
			(gpointer)self,
			-1
		);
		self->profiles_delete_button =
			gtk_toolbar_insert_stock (self->profiles_toolbar,
			GTK_STOCK_REMOVE,
			_("Delete this profile"),
			NULL,
			(GtkSignalFunc)profile_delete_cb /*cb*/,
			(gpointer)self,
			-1
		);

		gtk_widget_show (GTK_WIDGET (self->profiles_toolbar));

		self->profiles_sw = GTK_SCROLLED_WINDOW (gtk_scrolled_window_new (NULL, NULL));
		gtk_scrolled_window_set_policy (self->profiles_sw, GTK_POLICY_NEVER, GTK_POLICY_AUTOMATIC);
		gtk_widget_show (GTK_WIDGET (self->profiles_sw));

		self->profiles_model = GTK_TREE_STORE (gtk_tree_store_new (1, G_TYPE_STRING));

		self->profiles_tv = GTK_TREE_VIEW (gtk_tree_view_new ());
		gtk_tree_view_set_model (self->profiles_tv, GTK_TREE_MODEL (self->profiles_model));

		gtk_tree_view_append_column (self->profiles_tv, 
			tree_new_text_column (_("Profile"), 0
		));

		gtk_tree_view_set_headers_visible (self->profiles_tv, FALSE);

		gtk_widget_show (GTK_WIDGET (self->profiles_tv));

		gtk_container_add (GTK_CONTAINER (self->profiles_sw), GTK_WIDGET (self->profiles_tv));

		gtk_box_pack_start (GTK_BOX (self->profiles_box), GTK_WIDGET (self->profiles_toolbar), FALSE, FALSE, 0);
		gtk_box_pack_start (GTK_BOX (self->profiles_box), GTK_WIDGET (self->profiles_sw), TRUE, TRUE, 0);

		gtk_box_pack_start (GTK_BOX (self->hbox), GTK_WIDGET (self->profiles_box), TRUE, TRUE, 0);
		gtk_box_pack_start (GTK_BOX (self->hbox), GTK_WIDGET (self->sep1), FALSE, FALSE, 0);
		gtk_box_pack_start (GTK_BOX (self->hbox), GTK_WIDGET (self->detail), TRUE, TRUE, 0);
		gtk_box_set_spacing (GTK_BOX (self->hbox), 3);

		gtk_widget_set_size_request (GTK_WIDGET (self->hbox), -1, 200);

		/*self->profiles_insert_button;*/
		/*gtk_widget_set_sensitive (self->profiles_delete_button, FALSE);*/

		g_signal_connect_swapped (G_OBJECT (self->profiles_model),
			"row-inserted", G_CALLBACK (self_row_inserted_cb),
			self);

		g_signal_connect_swapped (G_OBJECT (self->profiles_model),
			"row-deleted", G_CALLBACK (self_row_inserted_cb),
			self);

		sels = gtk_tree_view_get_selection (self->profiles_tv);
		g_signal_connect_swapped (G_OBJECT (sels),
			"changed", G_CALLBACK (self_sel_changed_cb),
			self
		);

		g_signal_connect_swapped (G_OBJECT (profiles), 
			"profiles-changed",
			G_CALLBACK (self_profiles_changed_cb), self);

		self_profiles_updated (self);

		self_rowcnt_updated_cb (self);

		/*self_load (self);*/
	}

	protected void profiles_changed_cb (self, GObject *obj)
	{
		g_warning ("profiles_changed_cb start !!!!");
		self_profiles_updated (self);
		g_warning ("profiles_changed_cb end");
	}

	protected void sel_changed_cb (self, GtkTreeSelection *sel)
	{
		gboolean issel;
		GtkTreeModel *model;
		GtkTreeIter iter;
		gchar *s;
		XfceMixerProfile *p;

		g_warning ("sel_changed_cb start");

		/* TODO save current "detail" */

		issel = gtk_tree_selection_get_selected (sel, &model, &iter);

		if (issel) {
			gtk_tree_model_get (GTK_TREE_MODEL (self->profiles_model),
				&iter, 0, &s, -1);

			p = xfce_mixer_profiles_get_profile (profiles, s);

			xfce_mixer_profile_set_title (p, s);

			g_free (s);
			xfce_mixer_profilebox_detail_set_profile (self->detail, p);
		} else {
			xfce_mixer_profilebox_detail_set_profile (self->detail, NULL);
		}

		g_warning ("sel_changed_cb end");
	}

	/*
	protected gint profile_pos (self, gchar const *name)
	{
		GList *g;
		gint	i;
		g = self->profile_names;
		if (!name)
			return FALSE;

		i = -1;

		while (g) {
			++i;
			if (g_str_equal ((gchar const *)g->data, name))
				return i;

			g = g_list_next (g);
		}

		return -1;
	}
	*/

	protected gboolean profile_exists (self, gchar const *name)
	{
		XfceMixerProfile *p;
		if (!name)
			return TRUE;

		p = xfce_mixer_profiles_get_profile (profiles, name);
		if (p) {
			g_object_unref (G_OBJECT (p));
			return TRUE;
		}

		return FALSE;
	}

	protected void row_inserted_cb (self, GtkTreePath *path, GtkTreeIter *iter, GtkTreeModel *model)
	{
		if (self->profiles_updated_lock)
			return;

		g_warning ("row_inserted_cb start");

		self_rowcnt_updated_cb (self);

		g_warning ("row_inserted_cb end");
	}

	protected void row_deleted_cb (self, GtkTreePath *path, GtkTreeModel *model)
	{
		if (self->profiles_updated_lock)
			return;

		g_warning ("deleted");
		self_rowcnt_updated_cb (self);
	}

	protected void rowcnt_updated_cb (self)
	{
		gboolean b;

		b = gtk_tree_model_iter_n_children (GTK_TREE_MODEL (self->profiles_model), NULL) > 0;
		gtk_widget_set_sensitive (GTK_WIDGET (self->profiles_delete_button), b);
		gtk_widget_set_sensitive (GTK_WIDGET (self->detail), b);
	}

	public void profile_insert_cb(self)
	{

		g_warning ("insert p");
		self_new_dlg (self);
	}

	public void delete_profile(self, gchar const *name)
	{
		xfce_mixer_profiles_delete_profile (profiles, name);

		self_profiles_updated (self);
	}

	public void profile_delete_cb(self)
	{
		GtkTreeSelection *sels;
		GList *g;
		GList *gg;
		gint cnt;
		gchar const *q;
		gchar const *name;
		gchar *s;
		GtkResponseType rc;
		GtkWindow *parent;

		g_warning ("profile_delete_cb start");

		parent = GTK_WINDOW (gtk_widget_get_toplevel (GTK_WIDGET (self)));

		sels = gtk_tree_view_get_selection (self->profiles_tv);
		if (!sels)
			return;

		g = NULL;

		gtk_tree_selection_selected_foreach (sels, each_selstring_cb, (gpointer) &g);

		if (!g) /* nothing selected */
			return;

		cnt = g_list_length (g);
		if (cnt > 1) {
			q = _("Really delete those %d profiles?");
			s = g_strdup_printf (q, cnt);
		} else {
			q = _("Really delete profile \"%s\"?");
			s = g_strdup_printf (q, (gchar const *)g->data);
		}

		rc = annoy_user (parent, GTK_MESSAGE_QUESTION, GTK_BUTTONS_YES_NO, "%s", s);
		g_free (s);

		if (rc == GTK_RESPONSE_YES) {
			/* really delete */
			gg = g;
			while (gg) {
				name = (char const *)gg->data;
				if (name) {
					self_delete_profile (self, name);
				}
				gg = g_list_next (gg);
			}

			/* unfill right side */

			xfce_mixer_profilebox_detail_set_profile (self->detail, NULL);
		}

		if (g)
			stringlist_free (g);
		g_warning ("profile_delete_cb end");
	}

	protected void profiles_updated (self) /* profile list changed */
	{
		GtkTreeStore *store;
		GtkTreeSelection *sels;
		GList *g;
		gchar const *s;
		gchar *prevsel;
		GList *profile_names;
		GtkTreeIter iter;
		GtkTreeModel *model;

		if (self->profiles_updated_lock)
			return;

		self->profiles_updated_lock = 1;

		store = self->profiles_model;

		sels = gtk_tree_view_get_selection (self->profiles_tv);
		prevsel = NULL;
		if (gtk_tree_selection_get_selected (sels, &model, &iter)) {
			gtk_tree_model_get (model, &iter, 0, &prevsel, -1);
		}

		gtk_tree_store_clear (store);

		profile_names = xfce_mixer_profiles_get_profile_names (profiles);

		g = profile_names;
		while (g) {
			s = (gchar const *)g->data;
			gtk_tree_store_append (store, &iter, NULL);
			gtk_tree_store_set (store, &iter,
				0, s,
				-1
			);

			if (s && prevsel && g_str_equal (s, prevsel))
				gtk_tree_selection_select_iter (sels, &iter);

			g = g_list_next (g);
		}
		if (prevsel) {
			g_free (prevsel);
			prevsel = NULL;
		}

		stringlist_free (profile_names);

		self_rowcnt_updated_cb (self);

		self->profiles_updated_lock = 0;
	}

	protected void select_last (self)
	{
		gboolean b;
		GtkTreeSelection *sels;
		GtkTreeIter iter;
		GtkTreeIter piter;

		sels = gtk_tree_view_get_selection (self->profiles_tv);
		b = gtk_tree_model_get_iter_first (GTK_TREE_MODEL (self->profiles_model), &iter);
		if (b) {
			while (b) {
				piter = iter;
				b = gtk_tree_model_iter_next (
					GTK_TREE_MODEL (self->profiles_model), 
					&iter
				);
			}
			gtk_tree_selection_select_iter (sels, &piter);
		}
	}

	protected void new_dlg(self)
	{
		GtkDialog *dlg;
		gchar *s;
		GtkWindow *parent;
		XfceMixerProfileboxDetail *detail;
		XfceMixerProfile *p;
		gboolean retry;
		gchar const *name;
		parent =  GTK_WINDOW (gtk_widget_get_toplevel (GTK_WIDGET (self)));

		s = g_strdup_printf (
			_("%s - New"),
			gtk_window_get_title (parent)
		);
		dlg = GTK_DIALOG (gtk_dialog_new_with_buttons (
			s, parent,
			GTK_DIALOG_DESTROY_WITH_PARENT | GTK_DIALOG_MODAL,
			GTK_STOCK_CANCEL, GTK_RESPONSE_CANCEL,
			GTK_STOCK_OK, GTK_RESPONSE_OK,
			NULL
		));
		g_free (s);

		gtk_dialog_set_default_response (dlg, GTK_RESPONSE_OK);

		detail = xfce_mixer_profilebox_detail_new ();
		gtk_widget_show (GTK_WIDGET (detail));
		gtk_box_pack_start (GTK_BOX (dlg->vbox), GTK_WIDGET (detail), TRUE, TRUE, 0);

		gtk_widget_set_size_request (GTK_WIDGET (detail), -1, 200);

		p = XFCE_MIXER_PROFILE (xfce_mixer_profile_new (""));
		xfce_mixer_profilebox_detail_set_profile (detail, p);

		retry = TRUE;
		while (retry) {
			gtk_window_present (GTK_WINDOW (dlg));
			if (gtk_dialog_run (dlg) != GTK_RESPONSE_OK)
				break;

			retry = FALSE;
			name = xfce_mixer_profilebox_detail_get_name (detail);
			if (!name || !name[0]) {
				annoy_user (parent, GTK_MESSAGE_ERROR,
					GTK_BUTTONS_OK, "%s", 
				_("A profile needs a name"));
				retry = TRUE;
			} else if (!self_profile_exists (self, name)) {
				xfce_mixer_profile_set_title (p, name);
				xfce_mixer_profiles_add_profile (profiles, p);
				g_object_unref (G_OBJECT (p));
				/* TODO really insert */
				p = NULL;

				self_profiles_updated (self);
				self_select_last (self);
			} else {
				annoy_user (parent, GTK_MESSAGE_ERROR,
					GTK_BUTTONS_OK, "%s", 
				_("A profile with that name already exists"));
				retry = TRUE;
			}

		}
		gtk_widget_destroy (GTK_WIDGET (dlg));
		if (p) {
			g_object_unref (G_OBJECT (p));
		}
	}

	public Xfce:Mixer:Profilebox *new (void)
	{
		return XFCE_MIXER_PROFILEBOX (GET_NEW);
	}
}

%{
static void profile_insert_cb (GtkWidget *w, gpointer user_data)
{
	XfceMixerProfilebox *pb;
	pb = XFCE_MIXER_PROFILEBOX (user_data);
	xfce_mixer_profilebox_profile_insert_cb (pb);
}

static void profile_delete_cb (GtkWidget *w, gpointer user_data)
{
	XfceMixerProfilebox *pb;
	pb = XFCE_MIXER_PROFILEBOX (user_data);
	xfce_mixer_profilebox_profile_delete_cb (pb);
}

%}
