%{
#ifdef HAVE_CONFIG_H
#include <config.h>
#endif
%}
%a{
#include <gtk/gtk.h>
#include "vc.h"
#include "xfce-mixer-profile.h"
%}
%{
#include <libxfce4util/i18n.h>
#include "xfce-mixer-cache-vc.h"
#include "xfce-mixer-mcs-client.h"
#include "helpers3.inc"
#define emit

static void each_vccache_cb (volcontrol_t *vci, gpointer userdata);

extern XfceMixerMcsClient *mcsc;

%}

class Xfce:Mixer:Profilebox:Detail from Gtk:VBox {
	protected GtkEntry *detail_name_entry;
	protected GtkScrolledWindow *detail_sw;
	protected GtkBox *detail_box;
	protected GtkTreeView *detail_tv;
	protected GtkTreeStore *detail_model;
	protected gboolean dofill = FALSE;
	protected XfceMixerProfile *profile = NULL
		unrefwith g_object_unref;
	protected gchar *valids = NULL /* TODO autoupdate */
		destroywith g_free;

	public void set_profile (self, XfceMixerProfile *p)
	{
		gchar const *t;
		if (self->profile) {
			g_object_unref (G_OBJECT (self->profile));
			self->profile = NULL;
		}

		if (p) {
			self->profile = p;
			g_object_ref (G_OBJECT (p));
			t = xfce_mixer_profile_get_title (p);
			self_filln (self, t);
		} else
			self_unfill (self);
	}

	init(self)
	{
		GtkBox *nbox;
		GtkWidget *dlabel;

		self->detail_box = GTK_BOX (self);
		gtk_box_set_spacing (self->detail_box, 5);

		self->detail_sw = GTK_SCROLLED_WINDOW (gtk_scrolled_window_new (NULL, NULL));
		gtk_scrolled_window_set_policy (self->detail_sw, GTK_POLICY_NEVER, GTK_POLICY_AUTOMATIC);
		gtk_widget_show (GTK_WIDGET (self->detail_sw));

		self->detail_model = GTK_TREE_STORE (gtk_tree_store_new (
			4, G_TYPE_BOOLEAN, G_TYPE_STRING, G_TYPE_STRING,
			G_TYPE_STRING
		));

		self->detail_tv = GTK_TREE_VIEW (gtk_tree_view_new ());

		gtk_tree_view_append_column (self->detail_tv, 
			tree_new_check_column ("", 0, GTK_TREE_MODEL (self->detail_model)
		));
		gtk_tree_view_append_column (self->detail_tv, 
			tree_new_text_column (_("Control"), 1
		));
		gtk_tree_view_append_column (self->detail_tv, 
			tree_new_text_column (_("Type"), 2
		));
		/*gtk_tree_view_append_column (self->detail_tv, 
			tree_new_text_column (_("Location"), 3
		));*/

		gtk_tree_view_set_model (self->detail_tv, GTK_TREE_MODEL (self->detail_model));
		gtk_tree_view_set_headers_visible (self->detail_tv, TRUE);

		gtk_widget_show (GTK_WIDGET (self->detail_tv));

		gtk_container_add (GTK_CONTAINER (self->detail_sw), GTK_WIDGET (self->detail_tv));

		dlabel = gtk_label_new (_("Profile Name:"));
		gtk_widget_show (dlabel);

		self->detail_name_entry = GTK_ENTRY (gtk_entry_new ());
		gtk_entry_set_max_length (self->detail_name_entry, 79);
		gtk_widget_show (GTK_WIDGET (self->detail_name_entry));

		nbox = GTK_BOX (gtk_hbox_new (FALSE, 5));
		gtk_box_pack_start (nbox, GTK_WIDGET (dlabel), FALSE, FALSE, 0);
		gtk_box_pack_start (nbox, GTK_WIDGET (self->detail_name_entry), TRUE, TRUE, 0);
		gtk_widget_show (GTK_WIDGET (nbox));

		gtk_box_pack_start (GTK_BOX (self->detail_box), GTK_WIDGET (nbox), FALSE, FALSE, 0);

		gtk_box_pack_start (GTK_BOX (self->detail_box), GTK_WIDGET (self->detail_sw), TRUE, TRUE, 0);

		gtk_tree_view_set_reorderable (self->detail_tv, TRUE);
		g_signal_connect_swapped (G_OBJECT (self->detail_model),
			"rows-reordered", G_CALLBACK (self_rows_reordered_cb),
			self);

		gtk_entry_set_activates_default (self->detail_name_entry, TRUE);
	}

	public void clear(self)
	{
		gtk_entry_set_text (GTK_ENTRY (self->detail_name_entry), "");
		gtk_tree_store_clear (self->detail_model);
	}

	public gchar const *get_name(self)
	{
		return gtk_entry_get_text (self->detail_name_entry);
	}

	protected void fill (self)
	{
		self->dofill = TRUE;
		gtk_tree_store_clear (self->detail_model);
		if (self->valids)
			g_free (self->valids);
		self->valids = NULL;

		if (mcsc)
			self->valids = xfce_mixer_mcs_client_get_useful_controls (mcsc,
                                vc_get_device ());

		xfce_mixer_cache_vc_foreach ((GFunc)each_vccache_cb, self);
		gtk_widget_set_sensitive (GTK_WIDGET (self), TRUE);
		g_free (self->valids);
		self->valids = NULL;
	}

	protected void unfill (self)
	{
		self->dofill = FALSE;
		gtk_widget_set_sensitive (GTK_WIDGET (self), FALSE);
		self_clear (self);
	}

	public void filln (self, char const *pname)
	{
		gtk_entry_set_text (GTK_ENTRY (self->detail_name_entry), pname);
		self_fill (self);
	}

	public void each_vccache_cb (self, volcontrol_t *vci)
	{
		GtkTreeIter iter;
		gchar *ty;
		gchar *uct;
		gboolean b;

		b = FALSE;

		if (self->valids) {
			uct = g_strdup_printf ("@%s@", vci->name);
			if (uct) {
				b = g_strrstr (self->valids, uct) != NULL;
                                /*printf ("%s %s %d", uc , uct, (int)b );*/
				g_free (uct);
                        }   
                }

		if (!b) {
			return;
		}

		ty = _("<unknown>");
		switch(vci->type) {
		case CT_SLIDER: ty = _("<slider>"); break;
		case CT_ONOFF: ty = _("<onoff>"); break;
		case CT_SELECT: ty = _("<select>"); break;
		}

		gtk_tree_store_append (self->detail_model, &iter, NULL);
		gtk_tree_store_set (self->detail_model, &iter, 
			0, TRUE,
			1, vci->name, 
			2, ty,
		-1);
	}

	protected void rows_reordered_cb (self, GtkTreePath *arg1, GtkTreeIter *arg2,
		gpointer arg3, GtkTreeModel *model)
	{
		g_warning ("reordered");
	}


	public Xfce:Mixer:Profilebox:Detail *new(void) {
		return XFCE_MIXER_PROFILEBOX_DETAIL (GET_NEW);
	}
}

%{
static void each_vccache_cb (volcontrol_t *vci, gpointer userdata)
{
	XfceMixerProfileboxDetail *d;
	d = XFCE_MIXER_PROFILEBOX_DETAIL (userdata);

	if (vci && vci->name) {
		xfce_mixer_profilebox_detail_each_vccache_cb (d, vci);
	}
}
%}
