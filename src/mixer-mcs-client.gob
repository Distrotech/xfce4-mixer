%{
#ifdef HAVE_CONFIG_H
#  include <config.h>
#endif
%}
%a{
#include <gtk/gtk.h>
#include <libxfce4mcs/mcs-client.h>
%}
%{
#include <X11/Xlib.h>
#include <X11/Xatom.h>
#include <gdk/gdkx.h>
#include <libxfce4util/i18n.h>
#include "mixer-mcs-names.h"
#define emit

/* event handling */
static void
notify_cb (const char *name, const char *channel_name,
	   McsAction action, McsSetting * setting, void *data)
{
	XfceMixerMcsClient *m;
	m = XFCE_MIXER_MCS_CLIENT (data);

	if (!m->channel)
		return;

	if (g_ascii_strcasecmp (m->channel, channel_name))
		return;

    switch (action)
    {
	case MCS_ACTION_NEW:
	    /* fall through */
	case MCS_ACTION_CHANGED:
		xfce_mixer_mcs_client_update_setting (m, name, setting);
	    break;
	case MCS_ACTION_DELETED:
	    /* We don't use this now. Perhaps revert to default? */
	    break;
    }
}

static GdkFilterReturn
client_event_filter (GdkXEvent * xevent, GdkEvent * event, gpointer data)
{
	XfceMixerMcsClient *m;
	m = XFCE_MIXER_MCS_CLIENT (data);

	if (mcs_client_process_event (m->client, (XEvent *) xevent))
		return GDK_FILTER_REMOVE;
	else
		return GDK_FILTER_CONTINUE;
}

static void
watch_cb (Window window, Bool is_start, long mask, void *cb_data)
{
    GdkWindow *gdkwin;

    gdkwin = gdk_window_lookup (window);

    if (is_start)
	gdk_window_add_filter (gdkwin, client_event_filter, cb_data);
    else
	gdk_window_remove_filter (gdkwin, client_event_filter, cb_data);
}

%}

class Xfce:Mixer:Mcs:Client from G:Object {
	protected gchar *channel = NULL
		destroywith g_free;

	protected McsClient *client = NULL
		destroywith mcs_client_destroy;
	protected GHashTable *hash = NULL
		destroywith g_hash_table_destroy;

	property STRING channel (
		nick = "The mcs channel to use",
		blurb = "The mcs channel to use")
	get {
		g_value_set_string (VAL, self->channel);
	}
	set {
		if (self->channel) {
			g_free (self->channel);
			self->channel = NULL;
		}
		self->channel = g_strdup (g_value_get_string (VAL));
		mcs_client_add_channel (self->client, self->channel);
	};

	signal first NONE (NONE)
	void changed(self)
	{
		/*g_warning ("changed");*/
	}

	init(self)
	{
		Display *dpy = GDK_DISPLAY ();
		int screen = DefaultScreen (dpy);

		self->client = NULL;

		if (!mcs_client_check_manager (dpy, screen, "xfce-mcs-manager"))
			g_warning ("MCS settings manager not running!");
		else
			self->client = mcs_client_new (dpy, screen, notify_cb, watch_cb, self);

		self->hash = g_hash_table_new (g_str_hash, g_str_equal);
	}

	public void update_setting(self, gchar const *name, McsSetting *setting)
	{
		if (setting->type == MCS_TYPE_STRING) {
			g_hash_table_insert (self->hash, (gpointer)name, 
				(gpointer)setting->data.v_string);
		}
		emit self_changed (self);
	}

	public gchar *get_setting(self, gchar const *name)
	{
		gchar *s;
		McsSetting *setting;
		s = g_hash_table_lookup (self->hash, name);
		if (!s) {
			setting = NULL;
			mcs_client_get_setting (self->client, name, self->channel, &setting); /* return val ? */

			if (setting && setting->type == MCS_TYPE_STRING && setting->data.v_string) {
				return g_strdup (setting->data.v_string);
			}

			return NULL;
		}

		return g_strdup (s);
	}

	public gchar *get_useful_controls (self, gchar const *device)
	{
		gchar *n;
		gchar *s;
		if (!device)
			return NULL;

		n = g_strdup_printf (MIXER_USEFUL_FMT, device);
		s = self_get_setting (self, n);
		g_free (n);
		return s;
	}

	public XfceMixerMcsClient *new(void)
	{
		return XFCE_MIXER_MCS_CLIENT (GET_NEW);
	}
}
