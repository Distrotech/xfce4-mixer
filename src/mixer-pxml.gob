%{
#ifdef HAVE_CONFIG_H
#  include <config.h>
#endif
#ifdef HAVE_SYS_STAT_H
#include <sys/stat.h>
#endif
#include <stdio.h>
#ifdef HAVE_STDLIB_H
#include <stdlib.h>
#endif
#include <sys/types.h>


%}
%a{

#include <gtk/gtk.h>
#include <libxml/parser.h>
#include <libxml/tree.h>

%}

class Xfce:Mixer:Pxml from G:Object {
	protected gchar *root = NULL
		destroywith g_free;

	protected gboolean foreignDoc = TRUE;

	protected xmlDocPtr document = NULL
		destroy {
			self_free_document (self);
		};

	protected gchar * fname = NULL
		destroy {
			self_set_file (self, NULL);
		};

	property STRING fname (
		nick = "File name and path",
		blurb = "Filename and path to use, if any"
	)
	get {
		g_value_set_string (VAL, self->fname);
	}
	set {
		self_set_file (self, g_value_get_string (VAL));
	};

	public xmlNodePtr node = NULL;

	public void set_document (self, xmlDocPtr doc)
	{
		self->foreignDoc = TRUE;
		self->document = doc;
	}

	protected void free_document (self)
	{
		if (!self->foreignDoc && self->document) {
			xmlFreeDoc (self->document);
		}
		self->document = NULL;
	}

	protected void set_file (self, gchar const *fnamen)
	{
		gchar *dir;
		self->node = NULL;

		if (self->fname && self->document) {
			/* store blahblah if required */
			xmlSaveFormatFile (self->fname, self->document, 1);
			xmlFreeDoc (self->document);
			self->document = NULL;

			g_free (self->fname);
			self->fname = NULL;
		}

		if (fnamen) {
			self->fname = g_strdup (fnamen);
			if (!self->fname) {
				/* eeek TODO exception */
			}

			if (g_file_test (self->fname, G_FILE_TEST_EXISTS)) {
				/* TODO backup */
				self->document = xmlParseFile (self->fname);
				self->foreignDoc = FALSE;
			} else {
				/* create directory */
				dir = g_path_get_dirname (self->fname);
				if (dir && !g_file_test (dir, G_FILE_TEST_IS_DIR))
					mkdir (dir, S_IRWXU | S_IRGRP 
					| S_IXGRP | S_IROTH | S_IXOTH);

				if (dir)
					g_free (dir);
			}

			/* create document etc */

			if (!self->document && self->root) {
				self->document = xmlNewDoc ("1.0");
				self->document->children = xmlNewDocRawNode (self->document, NULL, self->root, NULL);
				self->foreignDoc = FALSE;
				xmlDocSetRootElement (self->document, self->document->children);
			}

			if (!self->document)
				return;

			self_goto_root (self);
			if (!self->node) { /* no root */
				xmlFreeDoc (self->document);
				self->document = NULL;
			}
		}
	}

	init(self)
	{
	}

	public void eat_children (self, GList *exceptions)
	{
		xmlNodePtr nodex;
		xmlNodePtr nnodex;
		GList *g;
		gchar *tagname;
		gboolean found;
		/* todo */
		if (!self->node)
			return;

		nodex = self->node->children;
		if (!nodex)
			return;

		while (nodex) {
			nnodex = nodex->next;

			/* if not nodex.tagname in exceptions:
				nodex.del()
			*/
			tagname = (gchar *)nodex->name;
			found = FALSE;
			g = exceptions;
			while (g) {
				if (g_str_equal ((gchar *)g->data, tagname)) {
					found = TRUE;
					break;
				}
				g = g_list_next (g);
			}

			if (!found) {
				/* delete node */
				xmlUnlinkNode (nodex);
				xmlFreeNode (nodex);
			}

			nodex = nnodex;
		}
	}

	public gboolean goto_next (self)
	{
		if (!self->node)
			return FALSE;

		self->node = self->node->next;
		if (self->node)
			return TRUE;

		return FALSE;
	}

	public gboolean check_tag (self, gchar const *tagname)
	{
		if (!self->node)
			return FALSE;

		return (xmlStrEqual(self->node->name, (const xmlChar *)tagname));
	}

	public gboolean goto_child_tag (self, gchar const *tagname)
	{
		xmlNodePtr nodex;
		if (!self->node)
			return FALSE;

		nodex = self->node->children;
		while (nodex) {
			if (xmlStrEqual(self->node->name, (const xmlChar *)tagname)) {
				self->node = nodex;
				return TRUE;
			}
			nodex = nodex->next;
		}

		return FALSE;
	}

	public gboolean has_parent (self)
	{
		if (!self->node)
			return FALSE;

		return (self->node->parent != NULL);
	}

	public void goto_parent (self)
	{
		if (!self->node)
			return;

		self->node = self->node->parent;
	}

	public void goto_children (self)
	{
		if (!self->node)
			return;

		self->node = self->node->children;
	}

	public void goto_root (self)
	{
		if (!self->document)
			return;

		self->node = xmlDocGetRootElement (self->document);

		if (self->root && !self_check_tag (self, self->root)) {
			self->node = NULL;
		}
	}

	public void goto_node(self, xmlNodePtr nn)
	{
		self->node = nn;
	}

	public gboolean has_children (self)
	{
		if (!self->node)
			return FALSE;

		return (self->node->children != NULL);
	}

	public gchar *get_prop (self, gchar const *pname)
	{
		return xmlGetProp (self->node, pname);
	}

	public void set_prop (self, gchar const *pname, gchar const *value)
	{
		xmlSetProp (self->node, pname, (const xmlChar *) value);
	}

	public xmlNodePtr create_text_child (self, gchar const *name, gchar const *opt_text)
	{
		if (!self->node)
			return NULL;

		return xmlNewTextChild (self->node, NULL, (const xmlChar *)name, (const xmlChar *) opt_text);
	}

	public XfceMixerPxml *new(gchar const *root)
	{
		XfceMixerPxml *p;
		p = XFCE_MIXER_PXML (GET_NEW);
		if (root)
			p->root = g_strdup (root);
		return p;
	}

	public gchar *get_text_child(self)
	{
		if (!self->node)
			return NULL;

		return xmlNodeListGetString(self->document, self->node->children, 1);
	}

}

