%a{
#include <gtk/gtk.h>
#include <libxfce4util/i18n.h>
#include <libxfcegui4/xfce_framebox.h>
#include <libxfce4mcs/mcs-manager.h>
%}
%{
#include "helpers3.inc"
#include "vc.h"
#include "stringlist.inc"

#undef SHOW_DEFAULT_DEVICE_ENTRY
#define SETTINGS_LIST_SEP "@"
#define CHANNEL "sound"
/*#define TRACE g_warning(s)*/

static void TRACE (gchar const *n)
{
}

%}

class Xfce:Mixer:Settingsbox from Gtk:VBox {
	protected GtkWidget *dev_frame = NULL;
	protected GtkLabel *dev_label = NULL;
	protected GtkWidget *useful_frame = NULL;
	protected GtkTreeView *useful_tv = NULL;
	protected GtkTreeStore *useful_model = NULL;
	protected GtkScrolledWindow *useful_sc = NULL;
	protected GtkTreeStore *devlist_model = NULL;
	protected GtkTreeView *devlist_tv = NULL;
	protected GtkScrolledWindow *devlist_sc = NULL;
	protected GtkBox *cols = NULL;
	protected GtkBox *right_box = NULL;
	protected GtkWidget *sep = NULL;
	protected GList *device_lst = NULL
		destroywith stringlist_free;
	protected gchar *sel_device = NULL
		destroywith g_free;

	public McsManager * manager = NULL;

	public void load (self) /* load from manager */
	{
		if (!self->manager)
			return;

		self_devicelst_updated (self);
	}

	public void save (self) /* save to manager */
	{
		if (!self->manager)
			return;

		self_device_changed_cb (self);
	}

	init (self)
	{
		GtkTreeSelection *sels;

		self->cols = GTK_BOX (gtk_hbox_new (FALSE, 5));
		gtk_widget_show (GTK_WIDGET (self->cols));

		self->sep = gtk_vseparator_new ();
		gtk_widget_show (GTK_WIDGET (self->sep));

		self->devlist_tv = GTK_TREE_VIEW (gtk_tree_view_new ());
		gtk_tree_view_append_column (self->devlist_tv, 
			tree_new_text_column (_ ("Device"), 0
			)
		);

		gtk_widget_show (GTK_WIDGET (self->devlist_tv));

		self->devlist_sc = GTK_SCROLLED_WINDOW (gtk_scrolled_window_new (NULL, NULL));
		gtk_scrolled_window_set_policy (self->devlist_sc, GTK_POLICY_NEVER, GTK_POLICY_AUTOMATIC);
		gtk_container_add (GTK_CONTAINER (self->devlist_sc), GTK_WIDGET (self->devlist_tv));
		gtk_widget_show (GTK_WIDGET (self->devlist_sc));

		self->devlist_model = GTK_TREE_STORE (gtk_tree_store_new (1, G_TYPE_STRING));
		gtk_tree_view_set_model (self->devlist_tv, GTK_TREE_MODEL (self->devlist_model));

		self->right_box = GTK_BOX (gtk_vbox_new (FALSE, 5));
		gtk_widget_show (GTK_WIDGET (self->right_box));

		self->dev_frame = xfce_framebox_new (_ ("Device"), TRUE);
		gtk_widget_show (GTK_WIDGET (self->dev_frame));

		self->dev_label = GTK_LABEL (gtk_label_new (_("None")));
		gtk_widget_show (GTK_WIDGET (self->dev_label));

		self->useful_frame = xfce_framebox_new (_ ("Useful Controls"), TRUE);
		gtk_widget_show (GTK_WIDGET (self->useful_frame));

		self->useful_tv = GTK_TREE_VIEW (gtk_tree_view_new ());

		gtk_tree_view_set_headers_visible (self->useful_tv, FALSE);

		gtk_widget_show (GTK_WIDGET (self->useful_tv));

		self->useful_model = GTK_TREE_STORE (gtk_tree_store_new (2, G_TYPE_BOOLEAN, G_TYPE_STRING));
		gtk_tree_view_set_model (self->useful_tv, GTK_TREE_MODEL (self->useful_model));

		gtk_tree_view_append_column (self->useful_tv, 
			tree_new_check_column ("", 0, GTK_TREE_MODEL (self->useful_model)
		));
		gtk_tree_view_append_column (self->useful_tv, 
			tree_new_text_column ("", 1
		));


		self->useful_sc = GTK_SCROLLED_WINDOW (gtk_scrolled_window_new (NULL, NULL));
		gtk_scrolled_window_set_policy (self->useful_sc, GTK_POLICY_NEVER, GTK_POLICY_AUTOMATIC);
		gtk_container_add (GTK_CONTAINER (self->useful_sc), GTK_WIDGET (self->useful_tv));
		gtk_widget_show (GTK_WIDGET (self->useful_sc));

		xfce_framebox_add (XFCE_FRAMEBOX (self->useful_frame), GTK_WIDGET (self->useful_sc));
		xfce_framebox_add (XFCE_FRAMEBOX (self->dev_frame), GTK_WIDGET (self->dev_label));

		gtk_box_pack_start (GTK_BOX (self->right_box), GTK_WIDGET (self->dev_frame), FALSE, FALSE, 0);
		gtk_box_pack_start (GTK_BOX (self->right_box), GTK_WIDGET (self->useful_frame), TRUE, TRUE, 0);

		gtk_box_pack_start (GTK_BOX (self->cols), GTK_WIDGET (self->devlist_sc), FALSE, FALSE, 0);
		gtk_box_pack_start (GTK_BOX (self->cols), GTK_WIDGET (self->sep), FALSE, FALSE, 0);
		gtk_box_pack_start (GTK_BOX (self->cols), GTK_WIDGET (self->right_box), FALSE, FALSE, 0);

		/*g_signal_connect_swapped (G_OBJECT (self->devlist_model), "row-changed", G_CALLBACK (self_device_changed_t_cb), self);*/

		sels = gtk_tree_view_get_selection (self->devlist_tv);
		if (sels) {
			g_signal_connect_swapped (G_OBJECT (sels), "changed", G_CALLBACK (self_device_changed_t_cb), self);
		}

		g_signal_connect_swapped (G_OBJECT (self), "destroy", G_CALLBACK (self_device_changed_d_cb), self);

		gtk_box_pack_start (GTK_BOX (self), GTK_WIDGET (self->cols), TRUE, TRUE, 0);

		/*self_devicelst_updated (self);*/

		gtk_widget_set_size_request (GTK_WIDGET (self), -1, 300);
	}

	private void device_changed_d_cb (self, gpointer user_data)
	{
		self_device_changed_cb (self);
	}

	private void device_changed_t_cb (self, 
			GtkTreeSelection *arg1
	)
	{
		self_device_changed_cb (self);
	}

	protected void device_changed_cb (self)
	{
		GtkTreeSelection *sels;
		GtkTreeModel *m;
		GtkTreeIter iter;
		gchar *s;
		GList *g;
		GList *cl;
		volcontrol_t *vci;
		TRACE ("enter device_changed_cb");

		self_apply_right_box (self);

		sels = gtk_tree_view_get_selection (self->devlist_tv);
		if (!sels)
			return;

		if (!gtk_tree_selection_get_selected (sels, &m, &iter))
			return;

		TRACE ("read selected device string");
		gtk_tree_model_get (m, &iter, 0, &s, -1);
		TRACE ("read selected device string ok");
		if (s) {
			TRACE (s);
			TRACE ("set dev_label");

			gtk_label_set_text (self->dev_label, s);
			TRACE ("set vc device");
			vc_set_device (s);
			TRACE ("free sel_device");
			if (self->sel_device) {
				g_free (self->sel_device);
				self->sel_device = NULL;
			}
			TRACE ("set sel_device");
			self->sel_device = g_strdup (s);
			TRACE ("free selected device string");

			g_free (s);
		}

		TRACE ("fill useful controls list");
		/* fill "useful controls" list */
		gtk_tree_store_clear (self->useful_model);

		cl = vc_get_control_list ();
		g = cl;
		while (g) {
			vci = (volcontrol_t *) g->data;

			if (vci && vci->name) {
				gtk_tree_store_append (self->useful_model, &iter, NULL);
				gtk_tree_store_set (self->useful_model, &iter, 
					0, TRUE,
					1, vci->name, 
				-1);

			}

			g = g_list_next (g);
		}
		TRACE ("fill vccl");
		if (cl)
			vc_free_control_list (cl);

		TRACE ("fill right_box soon");
		self_fill_right_box (self);
		TRACE ("leave device_changed_cb");

		mcs_manager_notify (self->manager, CHANNEL);
	}

	public void devicelst_updated (self)
	{
		GList *g;
		gchar const *s;
		GtkTreeIter iter;
		/*GtkTreeSelection *sels;*/
		if (self->device_lst) {
			stringlist_free (self->device_lst);
			self->device_lst = NULL;
		}
		TRACE ("enter devicelst_updated");
		self->device_lst = vc_get_device_list ();
		gtk_tree_store_clear (self->devlist_model);
		/*sels = gtk_tree_view_get_selection (self->devlist_tv);*/
		g = self->device_lst;
		while (g) {
			s = (gchar const *) g->data;
			if (s
#ifndef SHOW_DEFAULT_DEVICE_ENTRY
	&& !g_str_equal (s, "default")
#endif
			) {
				TRACE ("before append");
				gtk_tree_store_append (self->devlist_model, &iter, NULL);
				TRACE ("before set");
				gtk_tree_store_set (self->devlist_model, &iter, 0, s, -1);

				/*if (sels) {
					gtk_tree_selection_select_iter (sels, &iter);
					self_device_changed_cb (self);
				}*/
			}

			g = g_list_next (g);
		}
		/*if (sels && gtk_tree_model_get_iter_first (GTK_TREE_MODEL (self->devlist_model), &iter))
			gtk_tree_selection_select_iter (sels, &iter);*/
		TRACE ("leave devicelst_updated");
	}

	private gchar *mcs_s_name(self)
	{
		if (!self->sel_device)
			return NULL;

		return g_strdup_printf ("Sound/Mixer/Useful:%s", self->sel_device);
	}

	protected void fill_right_box (self)
	{
		gchar *n;
		gchar *s;
		gchar *s2;
		gchar *all;
		gboolean neof;
		gboolean b;
		McsSetting *setting;
		GtkTreeIter iter;
		if (!self->manager)
			return;

		n = self_mcs_s_name (self);
		if (!n)
			return;

	        if ((setting = mcs_manager_setting_lookup(self->manager,
                                        n, CHANNEL)) == NULL
		) {
			self_apply_right_box (self);
		}

	        if ((setting = mcs_manager_setting_lookup(self->manager,
                                        n, CHANNEL)) == NULL
		) {
			g_free (n);
			return;
		}

		g_free (n);

		all = setting->data.v_string;
		if (!all) 
			return;

		TRACE ("mcs_manager_setting_lookup");
		TRACE (all);

		neof = gtk_tree_model_get_iter_first (
			GTK_TREE_MODEL (self->useful_model), &iter);

		while (neof) {
			gtk_tree_model_get (GTK_TREE_MODEL (self->useful_model), 
				&iter, 1, &s, -1);

			b = FALSE;
			if (s) {
				s2 = g_strdup_printf ("%s%s%s", 
					SETTINGS_LIST_SEP,
					s,
					SETTINGS_LIST_SEP);
				g_free (s);
				s = s2;
				s2 = NULL;
			}

			if (s) {
				if (g_strrstr (all, s)) { /*contained*/
					b = TRUE;
				}
				g_free (s);
			}
			gtk_tree_store_set (
				self->useful_model,
				&iter, 
				0, b, -1);
			
			neof = gtk_tree_model_iter_next (GTK_TREE_MODEL (self->useful_model), &iter);
		}
			
		/*g_free (all);*/
		TRACE ("leave fill");
	}

	protected void apply_right_box (self)
	{
		gchar *n;
		gchar *v;
		gchar *v2;
		gchar *s;
		gboolean b;
		gboolean neof;
		GtkTreeIter iter;
		if (!self->sel_device || !self->manager)
			return;

		TRACE ("enter apply_right_box");

		v = g_strdup ("");

		neof = gtk_tree_model_get_iter_first (
			GTK_TREE_MODEL (self->useful_model), &iter);

		while (neof) {
			gtk_tree_model_get (GTK_TREE_MODEL (self->useful_model), 
				&iter, 0, &b, 1, &s, -1);

			if (s) {
				if (b) {
					v2 = g_strdup_printf("%s%s%s", v, SETTINGS_LIST_SEP, s);
					g_free (v);
					v = v2;
					v2 = NULL;
				}
				g_free (s);
			}			

			neof = gtk_tree_model_iter_next (
				GTK_TREE_MODEL (self->useful_model), &iter);
		}

		v2 = g_strdup_printf("%s%s%s", v, SETTINGS_LIST_SEP,  "");
		g_free (v);
		v = v2;
		v2 = NULL;

		n = self_mcs_s_name (self);
		if (!n)
			return;

		mcs_manager_set_string (self->manager,
                                n, CHANNEL, v);
		TRACE (n);
		TRACE ("mcs_manager_set_string");
		TRACE (v);
		g_free (n);

		TRACE ("leave apply_right_box");
	}

	public Xfce:Mixer:Settingsbox *new (void)
	{
		return XFCE_MIXER_SETTINGSBOX (GET_NEW);
	}
}
