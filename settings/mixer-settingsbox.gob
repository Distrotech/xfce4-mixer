%a{
/* needs modified gob2 that adds config.h first */
#include <gtk/gtk.h>
#include <libxfce4util/libxfce4util.h>
#include <libxfcegui4/xfce_framebox.h>
#include <libxfce4mcs/mcs-manager.h>
%}
%{
#include "helpers3.inc"
#include "vc.h"
#include "stringlist.inc"
#include "mixer-mcs-names.h"
#include "string_option_menu.h"
/*#include "btd.i"*/

#define SHOW_DEFAULT_DEVICE_ENTRY
#define SETTINGS_LIST_SEP "@"
#define CHANNEL "sound"
/*#define TRACE g_warning(s)*/

static gchar *fmt_device_cb(gchar const *c)
{
	gchar *s;
	if(!c)
		return NULL;

#ifndef SHOW_DEFAULT_DEVICE_ENTRY
	if (g_str_equal (c, "default"))
		return NULL;
#endif

	if (g_str_has_prefix (c, "/dev/")) {
		c = c + strlen("/dev/");
	}

	s = g_strdup (c);

	return s;
}

%}

class Xfce:Mixer:Settingsbox from Gtk:VBox {
	protected GtkWidget *dev_frame = NULL;
	protected GtkLabel *dev_label = NULL;
	protected GtkWidget *useful_frame = NULL;
	protected GtkTreeView *useful_tv = NULL;
	protected GtkTreeStore *useful_model = NULL;
	protected GtkScrolledWindow *useful_sc = NULL;
	protected GtkOptionMenu *devlist_om = NULL;
	protected GtkBox *cols = NULL;
	protected GtkBox *right_box = NULL;
/*	protected GtkWidget *sep = NULL;*/
	protected GList *device_lst = NULL
		destroy {
			stringlist_free(VAR);
			VAR = NULL;
		};
	protected gchar *sel_device = NULL
		destroy {
			if (VAR) {
				g_free (VAR);
				VAR = NULL;
			}
		};

	public McsManager * manager = NULL;

	public void load (self) /* load from manager */
	{
		McsSetting *setting;

		if (!self->manager)
			return;


		self_devicelst_updated (self);


		if (self->sel_device) {
			g_free (self->sel_device);
			self->sel_device = NULL;
		}

                if ((setting = mcs_manager_setting_lookup(self->manager,
                                        MIXER_DEFAULT_DEVICE_FIELD, CHANNEL)) != NULL) {
			self->sel_device = g_strdup (setting->data.v_string);
		}

		self_reselect_device (self);
	}

	public void save (self) /* save to manager */
	{
		if (!self->manager)
			return;

		self_device_changed_cb (self);

		if (self->sel_device) {
	                mcs_manager_set_string (self->manager, MIXER_DEFAULT_DEVICE_FIELD, CHANNEL, self->sel_device);
		}
		mcs_manager_notify (self->manager, CHANNEL);
	}

	init (self)
	{
		self->cols = GTK_BOX (gtk_hbox_new (FALSE, 5));
		gtk_widget_show (GTK_WIDGET (self->cols));

		/*self->sep = gtk_vseparator_new ();
		gtk_widget_show (GTK_WIDGET (self->sep));*/

		self->devlist_om = GTK_OPTION_MENU (gtk_option_menu_new ());
		gtk_widget_show (GTK_WIDGET (self->devlist_om));

		self->right_box = GTK_BOX (gtk_vbox_new (FALSE, 5));
		gtk_widget_show (GTK_WIDGET (self->right_box));

		self->dev_frame = xfce_framebox_new ( _("Device"), TRUE);
		gtk_widget_show (GTK_WIDGET (self->dev_frame));

		self->dev_label = GTK_LABEL (gtk_label_new (_("None")));
		/*gtk_widget_show (GTK_WIDGET (self->dev_label));*/

		/*debug_bindtextdomain();*/

		self->useful_frame = xfce_framebox_new ( _("Useful Controls"), TRUE);
		gtk_widget_show (GTK_WIDGET (self->useful_frame));

		self->useful_tv = GTK_TREE_VIEW (gtk_tree_view_new ());

		gtk_tree_view_set_headers_visible (self->useful_tv, FALSE);

		gtk_widget_show (GTK_WIDGET (self->useful_tv));

		self->useful_model = GTK_TREE_STORE (gtk_tree_store_new (2, G_TYPE_BOOLEAN, G_TYPE_STRING));
		gtk_tree_view_set_model (self->useful_tv, GTK_TREE_MODEL (self->useful_model));

		gtk_tree_view_append_column (self->useful_tv, 
			tree_new_check_column ("", 0, GTK_TREE_MODEL (self->useful_model)
		));
		gtk_tree_view_append_column (self->useful_tv, 
			tree_new_text_column ("", 1
		));


		self->useful_sc = GTK_SCROLLED_WINDOW (gtk_scrolled_window_new (NULL, NULL));
		gtk_scrolled_window_set_policy (self->useful_sc, GTK_POLICY_NEVER, GTK_POLICY_AUTOMATIC);
		gtk_container_add (GTK_CONTAINER (self->useful_sc), GTK_WIDGET (self->useful_tv));
		gtk_widget_show (GTK_WIDGET (self->useful_sc));

		xfce_framebox_add (XFCE_FRAMEBOX (self->useful_frame), GTK_WIDGET (self->useful_sc));
		xfce_framebox_add (XFCE_FRAMEBOX (self->dev_frame), GTK_WIDGET (self->devlist_om));
		/*xfce_framebox_add (XFCE_FRAMEBOX (self->dev_frame), GTK_WIDGET (self->dev_label));*/
		gtk_box_pack_start (GTK_BOX (self), GTK_WIDGET (self->dev_label), FALSE, FALSE, 0);

		gtk_box_pack_start (GTK_BOX (self->right_box), GTK_WIDGET (self->dev_frame), FALSE, FALSE, 0);
		gtk_box_pack_start (GTK_BOX (self->right_box), GTK_WIDGET (self->useful_frame), TRUE, TRUE, 0);

		/*gtk_box_pack_start (GTK_BOX (self->cols), GTK_WIDGET (self->devlist_om), FALSE, FALSE, 0);*/
		/*gtk_box_pack_start (GTK_BOX (self->cols), GTK_WIDGET (self->sep), FALSE, FALSE, 0);*/
		gtk_box_pack_start (GTK_BOX (self->cols), GTK_WIDGET (self->right_box), FALSE, FALSE, 0);

		/*g_signal_connect_swapped (G_OBJECT (self->devlist_model), "row-changed", G_CALLBACK (self_device_changed_t_cb), self);*/

		g_signal_connect_swapped (G_OBJECT (self->devlist_om), "changed", G_CALLBACK (self_device_changed_t_cb), self);

		/*g_signal_connect_swapped (G_OBJECT (self), "destroy", G_CALLBACK (self_device_changed_d_cb), self);*/

		gtk_box_pack_start (GTK_BOX (self), GTK_WIDGET (self->cols), TRUE, TRUE, 0);

		/*self_devicelst_updated (self);*/

		gtk_widget_set_size_request (GTK_WIDGET (self), -1, 300);
	}

	/*private void device_changed_d_cb (self, gpointer user_data)
	{
		self_device_changed_cb (self);
	}*/

	private void device_changed_t_cb (self, GtkOptionMenu *om)
	{
		self_device_changed_cb (self);
	}

	protected void device_changed_cb (self)
	{
		gchar const *s;
		GList *g;
		GList *cl;
		GtkTreeIter iter;
		volcontrol_t *vci;
		gint i;
		TRACE ("enter device_changed_cb");

		self_apply_right_box (self);

		i = gtk_option_menu_get_history (self->devlist_om);
		if ( i == -1)
			return;

		s = (gchar *)g_list_nth_data (self->device_lst, i);
		if (!s)
			return;

		if (s) {
			TRACE (s);
			TRACE ("set dev_label");

			gtk_label_set_text (self->dev_label, s);
			TRACE ("set vc device");
			vc_set_device (s);
			TRACE ("free sel_device");
			if (self->sel_device) {
				g_free (self->sel_device);
				self->sel_device = NULL;
			}
			TRACE ("set sel_device");
			self->sel_device = g_strdup (s);
			TRACE ("free selected device string");

			/*g_free (s);*/

			if (self->manager)
				mcs_manager_set_string (self->manager, MIXER_DEFAULT_DEVICE_FIELD, CHANNEL, self->sel_device);
		}

		TRACE ("fill useful controls list");
		/* fill "useful controls" list */
		gtk_tree_store_clear (self->useful_model);

		cl = vc_get_control_list ();
		g = cl;
		while (g) {
			vci = (volcontrol_t *) g->data;

			if (vci && vci->name) {
				gtk_tree_store_append (self->useful_model, &iter, NULL);
				gtk_tree_store_set (self->useful_model, &iter, 
					0, TRUE,
					1, vci->name, 
				-1);

			}

			g = g_list_next (g);
		}
		TRACE ("fill vccl");
		if (cl)
			vc_free_control_list (cl);

		TRACE ("fill right_box soon");
		self_fill_right_box (self);
		TRACE ("leave device_changed_cb");

		mcs_manager_notify (self->manager, CHANNEL);
	}

	public void devicelst_updated (self)
	{
		gint	i;
		gint	cnt;
		gint	active;
		active = 0;
		gchar const *s;
		gchar	*old_sel_device;

		old_sel_device = NULL;
		if (self->sel_device)
			old_sel_device = g_strdup (self->sel_device);

		if (self->device_lst) {
			stringlist_free (self->device_lst);
			self->device_lst = NULL;
		}
		self->device_lst = vc_get_device_list ();

		fill_string_option_menu_2 (
			self->devlist_om, 
			self->device_lst,
			fmt_device_cb
		);


		if (!self->device_lst)
			return;

		cnt = g_list_length (self->device_lst);
		for(i = 0; i < cnt; i++) {
			gtk_option_menu_set_history (self->devlist_om, i);
			self_device_changed_cb (self);
			s = (gchar *)g_list_nth_data (self->device_lst, i);
			if (s && old_sel_device && g_str_equal (old_sel_device, s)) {
				active = i;
			}
		}
		if (cnt > 0)
			gtk_option_menu_set_history (self->devlist_om, active);

		if (old_sel_device)
			g_free (old_sel_device);
	}

	protected void reselect_device(self)
	{
		gint cnt;
		gint i;
		gint active;
		gchar const *s;

		active = 0;
		cnt = g_list_length (self->device_lst);
		for(i = 0; i < cnt; i++) {
			s = (gchar const *)g_list_nth_data (self->device_lst, i);
			if (s && self->sel_device && g_str_equal (self->sel_device, s)) {
				active = i;
			}
		}

		if (cnt > 0) {
			gtk_option_menu_set_history (self->devlist_om, active);
			self_device_changed_cb (self);
		}
	}

	private gchar *mcs_s_name(self)
	{
		if (!self->sel_device)
			return NULL;

		return g_strdup_printf (MIXER_USEFUL_FMT, self->sel_device);
	}

	protected void fill_right_box (self)
	{
		gchar *n;
		gchar *s;
		gchar *s2;
		gchar *all;
		gboolean neof;
		gboolean b;
		McsSetting *setting;
		GtkTreeIter iter;
		if (!self->manager)
			return;

		n = self_mcs_s_name (self);
		if (!n)
			return;

	        if ((setting = mcs_manager_setting_lookup(self->manager,
                                        n, CHANNEL)) == NULL
		) {
			self_apply_right_box (self);
		}

	        if ((setting = mcs_manager_setting_lookup(self->manager,
                                        n, CHANNEL)) == NULL
		) {
			g_free (n);
			return;
		}

		g_free (n);

		all = setting->data.v_string;
		if (!all) 
			return;

		TRACE ("mcs_manager_setting_lookup");
		TRACE (all);

		neof = gtk_tree_model_get_iter_first (
			GTK_TREE_MODEL (self->useful_model), &iter);

		while (neof) {
			gtk_tree_model_get (GTK_TREE_MODEL (self->useful_model), 
				&iter, 1, &s, -1);

			b = FALSE;
			if (s) {
				s2 = g_strdup_printf ("%s%s%s", 
					SETTINGS_LIST_SEP,
					s,
					SETTINGS_LIST_SEP);
				g_free (s);
				s = s2;
				s2 = NULL;
			}

			if (s) {
				if (g_strrstr (all, s)) { /*contained*/
					b = TRUE;
				}
				g_free (s);
			}
			gtk_tree_store_set (
				self->useful_model,
				&iter, 
				0, b, -1);
			
			neof = gtk_tree_model_iter_next (GTK_TREE_MODEL (self->useful_model), &iter);
		}
			
		/*g_free (all);*/
		TRACE ("leave fill");
	}

	protected void apply_right_box (self)
	{
		gchar *n;
		gchar *v;
		gchar *v2;
		gchar *s;
		gboolean b;
		gboolean neof;
		GtkTreeIter iter;
		if (!self->sel_device || !self->manager)
			return;

		TRACE ("enter apply_right_box");

		v = g_strdup ("");

		neof = gtk_tree_model_get_iter_first (
			GTK_TREE_MODEL (self->useful_model), &iter);

		while (neof) {
			gtk_tree_model_get (GTK_TREE_MODEL (self->useful_model), 
				&iter, 0, &b, 1, &s, -1);

			if (s) {
				if (b) {
					v2 = g_strdup_printf("%s%s%s", v, SETTINGS_LIST_SEP, s);
					g_free (v);
					v = v2;
					v2 = NULL;
				}
				g_free (s);
			}			

			neof = gtk_tree_model_iter_next (
				GTK_TREE_MODEL (self->useful_model), &iter);
		}

		v2 = g_strdup_printf("%s%s%s", v, SETTINGS_LIST_SEP,  "");
		g_free (v);
		v = v2;
		v2 = NULL;

		n = self_mcs_s_name (self);
		if (!n)
			return;

		mcs_manager_set_string (self->manager,
                                n, CHANNEL, v);
		TRACE (n);
		TRACE ("mcs_manager_set_string");
		TRACE (v);
		g_free (n);

		TRACE ("leave apply_right_box");
	}

	public Xfce:Mixer:Settingsbox *new (void)
	{
		return XFCE_MIXER_SETTINGSBOX (GET_NEW);
	}
}
